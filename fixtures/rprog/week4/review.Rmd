# Review exercises

For the tasks in this section you need to load a data file `t2.RData`, which you can download from

- http://www.stats.gla.ac.uk/~levers/rp/t2.RData

If you run R on a computer connected to the internet, you can simply run
```{r}
load(url("http://www.stats.gla.ac.uk/~levers/rp/t2.RData"))
```


###[task]
This task is identical to ref://task_alcohol_classic. This time however, you are meant to use the functions from `tidyverse` to answer the questions. We can also look at two more questions.


In this task you will use the table `alcohol` (available from `t2.RData`)  which contains the average weekly consumption of alcohol in UK units based on age group, gender and type of drink (data from England, 2009; data obtained from http://data.gov.uk). The data frame `alcohol` has the following columns.

| Column name  | Description |
|--------------|---------------------|
|`Drink` | Type of alcoholic drink|
|`Gender` | gender ("Men" / "Women")|
|`Age` | Age group ("16-24", "25-44", "45-64", "65+")|
|`Units` | Weekly alcohol consumption in units|

- Print the alcohol consumption data relating to women aged 16-24. 
- Find the total alcohol consumption in units for women aged 16-24.
- Create a new data set `total_alcohol` which contains for both genders and each group the total alcohol consumption in units. The table should have three columns: "Age", "Gender" and "Units". 
- For both genders and each age group find the type of drink which is consumed the most (i.e. which contributes most to the overall alcohol consumption for that group).
- Rearrange the data from `total_alcohol` in wide matrix layout. The rows should correspond to the age groups and the columns to gender.


####[answer]

\mbox{ }

#####[video, videoid="fXrma_pmYUg", duration="4m16s"] Video model answers




We can use the following R code.
```{r}
alcohol %>%
    filter(Gender=="Women" & Age=="16-24")

alcohol %>%
    filter(Gender=="Women" & Age=="16-24") %>%
    select(Units) %>%
    colSums()

total_alcohol <- alcohol %>% 
                   group_by(Age, Gender) %>%
                   summarise(Units=sum(Units))

alcohol %>% 
   group_by(Age, Gender) %>%
   filter(Units==max(Units)) %>%
   select(Age, Gender, Drink)

library(tidyr)
total_alcohol %>%
    spread(Gender, Units)
```
####[/answer]

###[/task]

###[task, label="task_brexit"]Voting patterns in the EU referendum 
After you have loaded `t2.RData` you should have a data frame `brexit` in your workspace. The data frame contains information on the outcome of the EU referendum for each local authority in England and Wales. 

####[columns]
#####[column, width=12]
| Variable name | Description |
|-----------|------------------|
|`LACode` | ONS code of the local authority|
|`LAName` | name of the local authority|
|`Region` | region the local authority is located in|
|`Leave` | percentage of votes in favour of leaving the EU|
|`EUMigrants`   | percentage of EU migrants in this local authority|
  
A second data frame `sgrades` contains data on each social grade (AB, C1, C2 and DE) for each local authority. It has three columns

| Variable name | Description |
|-----------|------------------|
|`LACode` | ONS code of the local authority|
|`SocialGrade` | Social grade|
|`Count`| Number of adults in given local authority and social grade|
#####[/column]
####[/columns]

The social grades are defined as follows.

| Social grade | Description |
|--------|--------------------|
|AB | managerial, administrative or professional|
|C1 | supervisory or clerical and junior managerial, administrative or professional (includes students)|
|C2 | skilled manual workers |
|D | semi-skilled and unskilled manual workers|
|E | casual workers, pensioners, dependent on benefits|


Augment the dataset `brexit` by five columns: the proportion of social grade AB, C1, C2 and DE as well as the most prevalent social grade.

####[answer]

\mbox{ }


#####[video, videoid="_5_vQDlxylM", duration="9m14s"] Video model answers


We can use the following R code.
```{r, out.width=".5\textwidth"}
sgrades_wide <- sgrades %>%
                  group_by(LACode) %>%
                  mutate(Count=Count/sum(Count)) %>%
                  spread(SocialGrade, Count)   
   
# We can then merge this data into brexit

brexit <- brexit %>%
            inner_join(sgrades_wide)
 
# To find the most prevalent social grade we can use

sgrades_mostprev <- sgrades %>%
                      group_by(LACode) %>%
                      arrange(Count) %>%
                      slice(n()) %>%
                      select(-Count)

brexit <- brexit %>%
    inner_join(sgrades_mostprev)

# We can then, for example plot the leave vote against the proportion
# of social grade C2 (not required)

library(ggplot2)
qplot(C2, Leave, data=brexit)
```
```{r, out.width=".5\textwidth"}
qplot(EUMigrants, Leave, colour=SocialGrade, data=brexit)
```
####[/answer]
###[/task]

###[task]Voting patterns in the EU referendum (continued - hard)
In this task you will work again with the data on the EU referendum and relate it to the results of the 2015 General Election. The challenge however is that the results for the EU referendum are only available on a local-authority basis, whereas the results for the General Election are only available at constituency level. Though constituencies and local authorities sometimes coincide, this is not generally the case. For the General Election, we thus need to estimate the result in a local authority by combining the results from the constituencies it overlaps with.

Suppose a local authority consists of three wards W1 W2,and W3, which are part of two different constituencies, C1 (W1) and C2 (W2 and W3).

```{r echo=FALSE, out.width=".5\textwidth"}
knitr::include_graphics('./ward_figure.pdf')
```

Suppose that the we have observed the following results in the two constituencies.

####[columns]
#####[column, width=12]

| Constituency | Votes for party A | Total votes | Electorate | Share for party A | Turnout |
|------------|------------|------------|------------|------------|------------|
|C1 | 1000 | 2000 | 2500 | 1000/2000=50%| 2000/2500=80% |
|C2 | 750 | 3000 | 4000 | 750/3000=25%   | 3000/4000=75% |

| Wards | Constituency | Electorate |
|---------|---------|---------|
|W1 | C1 | 800 |
|W2 | C2 | 900 |
|W3 | C2 | 700 |


The estimated share of the vote for party A in the local authority is then estimated by a weighted mean, in which the weights are the product of the electorate of the ward and the turnout of the corresponding constituency. 

Thus the estimated vote share of party A in the local authority is 
$$
\frac{800\times 0.8 \times 0.5 + 900 \times 0.75 \times 0.25 + 700 \times 0.75 \times 0.25}{800\times 0.8 + 900 \times 0.75 + 700 \times 0.75}\approx 0.3370 = 33.70\%
$$

Using the counts we can rewrite this as 
$$
\frac{800\times \frac{1000}{2500} + 900 \times  \frac{750}{4000}+ 700 \times \frac{750}{4000}}{800\times \frac{2000}{2500} + 900 \times \frac{3000}{4000} + 700 \times \frac{3000}{4000}}\approx 0.3370 = 33.70\%
$$

The data required in this task are contained in the data frames `genelec` and `wards`.
#####[/column]
####[/columns]

|Variable name |Description|
|----------|-------------------|
|`ConstituencyCode` | ONS code of the constituency|
|`ConstituencyName` | name of the constituency|
|`Country` | country (``England'' or ``Wales'')|
|`ConVote` | number of votes cast for the Conservatives|
|`LabVote` | number of votes cast for Labour|
|`LDVote` | number of votes cast for the Liberal Democrats|
|`UKIPVote` | number of votes cast for the Greens|
|`TotalVote` | Total number of votes cast|
|`Electorate` | Number of voters entitled to vote (electorate)|


|Variable name |Description|
|----------|-------------------|
| `WardCode` | ONS code of the ward|
| `WardName` | name of the ward|
| `ConstituencyCode` | ONS code of the constituency|
| `LACode` | ONS code of the local authority|
| `Population` | population of the ward|
| `Electorate` | electorate in the ward|
  
Augment the data set `brexit` so that it also contains the vote shares for each party on a local-authority-basis.

####[answer]
We start by augmenting the ward data by the estimated number of votes for each party and turnout.
```{r}
wards_extended <- wards %>% 
                  inner_join(genelec, by="ConstituencyCode", 
                             suffix=c("Ward","Const")) %>%
                  mutate(ConVote=ConVote/ElectorateConst*ElectorateWard,
                         LabVote=LabVote/ElectorateConst*ElectorateWard,
                         LDVote=LDVote/ElectorateConst*ElectorateWard,
                         UKIPVote=UKIPVote/ElectorateConst*ElectorateWard,
                         GreenVote=GreenVote/ElectorateConst*ElectorateWard,
                         TotalVote=TotalVote/ElectorateConst*ElectorateWard) 
```

We now aggregate the ward data by local authority and divide by the total (estimated) numbers of votes cast.
```{r}
la_shares <- wards_extended %>% 
               group_by(LACode) %>%
               summarise(ConVote=sum(ConVote)/sum(TotalVote),
                  LabVote=sum(LabVote)/sum(TotalVote),
                  LDVote=sum(LDVote)/sum(TotalVote),
                  UKIPVote=sum(UKIPVote)/sum(TotalVote),
                  GreenVote=sum(GreenVote)/sum(TotalVote))
```

`dplyr` provides the functions `mutate_at` and `summarise_at`, which allow for applying the same transformation to a number of column in one go.
```{r}
wards_extended <- wards %>% 
                  inner_join(genelec, by="ConstituencyCode", 
                             suffix=c("Ward","Const")) %>%
                  mutate_at(vars(ConVote:TotalVote), 
                            funs(./ElectorateConst*ElectorateWard))

la_shares <- wards_extended %>% 
               group_by(LACode) %>%
               summarise_at(vars(ConVote:GreenVote),
                            funs(sum(.)/sum(TotalVote)))
```

We can now for example plot the Leave vote against the UKIP vote.
```{r, out.width=".5\\textwidth"}
qplot(UKIPVote, Leave, data=brexit %>% inner_join(la_shares))
```

####[/answer]


###[/task]
