## Reading in data using readr

The package [readr](https://cran.r-project.org/web/packages/readr/index.html) contains alternatives to the functions `read.table` and `read.csv`. The alternative functions from `readr` have four main advantages.

- They read in the data a lot faster and can show a progress bar (though this is only relevant for really big data sets).
- They store the data straight in a tibble, rather than a data frame.
- They allow specifying the intended data type for each column and thus make it easier to identify rows which cause problems.
- They are less intrusive: they don't automatically convert character strings to factors and do not change column names (`read.table` and `read.csv` will for example remove spaces from variable names and replace them by full stops). The functions from `readr` are also guaranteed to give the same result irrespective of the platform or operating system they are run under.

`readr` provides the following functions.

- `read_csv` reads in comma-separated files. `read_csv2` reads in files which are semicolon-separated (common in countries like France or Germany, where a comma is used as decimal separator).
- `read_tsv` reads in tab-separated files.
- `read_delim` is the most general function (like `read.table`). The delimiter has to be specified using the argument `delim`.
- `read_fwd` reads in fixed-width files. 

All functions assume that the first row contains the column/variable names. If this is not the case, set the optional argument `col_names` to `FALSE` or to a character vector containing the intended column names.

The strings used to encode missing values can be specified using the optional argument `na`.

For example, we can read in the file [chol.txt](http://www.stats.gla.ac.uk/~levers/rp/chol.txt) from week 3 using 
```{r}
library(readr)
read_delim("chol.txt", delim=" ", col_names=c("ldl", "hdl", "trig",
                                              "age", "gender", "smoke"))
```
Note that functions from `readr` show the data type it has used for each column. This makes it easier to spot mistakes like missing values not coded as expected, in which case a numeric column would show up as a character string.

For example, we can read in the file [chol.csv](http://www.stats.gla.ac.uk/~levers/rp/chol.csv) from week 3 using 
```{r}
library(readr)
read_csv("chol.csv", na=".")
```

#####[task]
Read the data files [cars.csv](http://www.stats.gla.ac.uk/~levers/rp/cars.csv) and [ships.txt](http://www.stats.gla.ac.uk/~levers/rp/ships.txt) from week 3 into R using the functions from `readr`.


######[answer]
The first line of the file `cars.csv` contains the variable names and the fields are separated by commas. Missing values are encoded as asterisks.
```{r}
cars <- read_csv("cars.csv", na="*")
cars
```
We could have also used the function `read_delim`.
```{r}
read_delim("cars.csv", delim=",", na="*")
```
The first line of the file `ships.txt` contains the variable names and the fields are separated by whitespace. Missing values are encoded as ".".
```{r}
ships <- read_delim("ships.txt", delim=' ' , na=".")
ships
```
######[/answer]


#####[/task]

####[supplement]Specifying column types
The functions from `readr` allow specifying the expected column types. This is especially important when writing which will then be run automatically. It provides an easy way of ensuring that the data provided is of the expected format.

The easiest way of specifying expected column types is to provide a character string with each letters standing for a column

| Letter  | Meaning   |
|--|------------------|
|`c`| character       |
|`i`| integer         |
|`n`| number          |
|`d`| double          |
|`l`| logical         |
|`D`| date            |
|`T`| date time       |
|`t`| time            |
|`?`| guess the type  |
|`_` or `-`| skip the column |

So for the data file chol.csv we would expect the first four columns to be integers and the latter two to be character strings, so we would use
```{r}
chol <- read_csv("chol.csv", na=".", col_types="iiiicc")
```

Specifying the expected column types can help pinpointing problems when reading in data. Suppose we had forgotten that missing values are coded using "`.`" in this data file. If we use ...
```{r}
chol <- read_csv("chol.csv")
```
... we  can see from the output that `trig` was read in as a character string, but we do not know why.

However, if we use ...
```{r}
chol <- read_csv("chol.csv", col_types="iiiicc")
```
... we obtain a warning and can print the problematic rows using
```{r}
problems(chol)
```
The output from `problems` shows us that for three rows (3, 7 and 9) the data in `chol.csv` was not of the expected format: a value of `.` is not compatible with the column being numeric. This makes it easy to identify the cause of the problem (NAs coded as "`.`") and rectify the issue.
####[/supplement]

###[weblink, target="https://github.com/rstudio/cheatsheets/raw/master/data-import.pdf"]Data Import Cheat Sheet
RStudio's cheat sheet for data import also covers `readr`.
###[/weblink]

###[weblink, target="http://r4ds.had.co.nz/data-import.html", icon="book"]Background reading: Chapter 11 of R for Data Science
Chapter 11 of *R for Data Science* gives a detailed overview of the functions in `readr`. It explains in some more detail how the functions in `readr` parse files. over pipes and also covers the functions from `readr` that dead with writing files.
###[/weblink]


<!--[if PDF]>
\newpage
<![endif]-->
