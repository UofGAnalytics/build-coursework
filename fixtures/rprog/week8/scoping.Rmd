## Scoping

###[video,videoid=vvAeaoB47V8] Scoping

When writing your own functions it is important that you distinguish
between variables available locally in the function and variables
available in your workspace (or in a parent function, from which your function is being called), i.e. outside your function.

Every variable that exists outside the function can be referenced and
used inside the function. However, as soon as you change any of these
variables, a local copy will be created: the changes you make to this
variable will be only temporary. Once the function has finished running,
the changes will be rolled back. Similarly, if you create a new
variable, it will only be created temporarily and will be deleted once
you exit from the function, unless you return it using the function
`return` or by putting the object in the last line of the function
body. 

In R, all arguments (with the exception of environments) are always passed on to the function by value.

####[example]
Consider the following function. 
```{r}
test <- function(a) {
  print(b)
  b <- a
  print(b)
}
```
This function is certainly not best practice, but a valid R function.
```{r}
b <- 19
test(13)
b
```
Whilst the variable `b` visible inside the function is 13, the variable `b` in the workspace has retained the value 19. 

The table below shows how the variables in the workspace and the local variables in the function change as the statements inside the function get run.

| Commands entered | Commands run in function | Variables in workspace | Local variables in function | Comment    | 
|---------------|---------------|---------------|---------------|--------------------|
| `b <- 19`     | --            | `b=19`        | --            | --            |
| `test(13)`    | `print(b)`    | `b=19`        | `a=13`        | Prints 19     |
|               | `b <- a`      | `b=19`        | `a=13`, `b=13`| Local `b` masks `b` from workspace |
|               | `print(b)`    | `b=19`        | `a=13`, `b=13`| Prints 13     |
| `print(b)`    | --            | `b=19`        | --            | Prints 19     |

####[/example]

The fact that you can access objects available outside functions does not mean you should do this.

### Good practice
Functions should be self-contained units, so all inputs should be passed
on as arguments and all outputs should be `return`ed. Thus when writing
a function, you should use inside the function only:

- variables that are passed on to the function as arguments, and

- local variables you have defined inside the function.

You can access variables available only in the workspace, but this is
typically (and for good reason) considered to be bad programming style.
The following example illustrates why.

####[example]
Suppose you want to write your own function for computing
the mean of a vector `x`.
```{r}
x <- 1:10                            # Set x
n <- length(x)                       # Determine length of x
my.mean <- function(x) {
  x.bar <- sum(x) / n                # Compute mean
  x.bar
}
```
When you want to compute the mean of `x`, you can now run
```{r}
my.mean(x)
```
which returns the correct mean. So, at first sight everything seems fine. However when we run
```{r}
y <- 1:3
my.mean(y)
```
rather than 3, the correct value. Why did this happen? When looking at
the implementation of `my.mean` we computed the length `n` *outside* the
function, thus we assumed that there is a variable `n` in the workspace
which holds the length of the vector whose mean we want to compute. This
was the case for `x`, but is not the case for `y`.

According to the advice given above, we should not have used `n` in the
function without having it first set to the length of `x` inside the
function. Thus we should have coded the function `my.mean` as follows:
```{r}
my.mean <- function(x) {
  n <- length(x)                     # Determine length of x - now inside function
  x.bar <- sum(x) / n                # Compute mean
  x.bar
}
```
####[/example]


<!--[if PDF]>
\newpage
<![endif]-->


