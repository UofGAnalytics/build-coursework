## Designing functions

Programming is, just like mathematical proofs, an art. 

###[background] The Art of Computer Programming
The [Art of Computer Programming](http://www-cs-faculty.stanford.edu/~knuth/taocp.html) is also the title of a monograph by the American Computer Scientist Donald E. Knuth (who also developed the typesetting system [TeX](https://en.wikipedia.org/wiki/TeX)). Although written almost 50 years ago, it still is the single most influential book in Computer Science. It is however far from being an easy read. Bill Gates (former CEO of Microsoft and until 2010 the wealthiest man in the world) once said: "If you think you're a really good programmer, or if you want to challenge your knowledge, read The Art of Computer Programming by Donald Knuth. I studied 20 pages, put it away for a week, and came back for another 20 pages. If somebody is so brash that they think they know everything, Knuth will help them understand that the world is deep and complicated. If you can read the whole thing, send me a resume."
###[/background]


### Plan before you code
When working on more complex programming tasks, take the time to plan before you start coding. Structuring a problem is often the key step to getting things right. Once you have broken down a problem into small, more manageable pieces it is a lot easier to code these up. There are no cook-book recipes that can guarantee you success. Below are a few hints which I found useful.

Keep in mind that your code doesn't just need to work. It also has to be maintainable both by others and future you. If you structure your code in terms of short well-defined (and documented) functions, your code is a lot easier to read, test, maintain and debug. 

Often, going through the following steps helps tackling a complex programming problem:

1. Try to understand the problem you are trying to solve. If you don't know where to start, think of a simple special case.
2. Work out which steps are required to solve the problem. When working on a complex problem, think how you could divide the problem into smaller (and hopefully easier) sub-tasks. It is often a good idea to use a "top-down" design: split your main task into at most a dozen sub-steps. If necessary, split these sub-steps again into "sub-sub-steps" etc. until you end up with small enough steps which are straightforward to implement.
It might help writing up your steps as "instructions" in plain English, or using flow diagrams or pseudo-code (use whatever works best for you).
For complex problems, this step is by far the most difficult.
3. Translate each of these (sub-)steps  into code. Make sure you document your functions properly. For each function explain at least what the function does, what arguments it takes, and what it returns.
4. Check your program. Does it work? Try out a few examples. If you can think  of difficult special cases, try your program with these. Do not only test the final main function, but also test the functions implementing the sub-steps individually: this way you are not only more likely to find a mistake, it is also easier to locate what has gone wrong. If any of the functions does not do what it should, you need to find the mistake (more on this [ref://debug](later on)).


####[task]The Wheels on the Bus
**The Wheels on the Bus** is an American folk song which is nowadays a popular nursery song in the English speaking world. There are many variants, a common one is
```
The wheels on the bus go round and round,
round and round, round and round.
the wheels on the bus go round and round,
all day long.

The wipers on the bus go swish swish swish,
swish swish swish, swish swish swish.
the wipers on the bus go swish swish swish,
all day long.

The horn on the bus goes beep beep beep,
beep beep beep, beep beep beep.
the horn on the bus goes beep beep beep,
all day long.

The people on the bus go up and down,
up and down, up and down.
the people on the bus go up and down,
all day long.
```

Write an R function or a set of R functions which produce the lyrics as efficiently as possible. Ideally make your function also customisable, that verses can be added.

You can use the base function `paste` or the function `str_c` from `stringr` to concatenate strings.

#####[answer]
We will write two functions: the first one generates a single verse and the second one uses the first function to produce all the lyrics.

The prototype for a verse is
```
The <object> on the bus <go or goes> <what>,
<what>, <what>.
The <object> on the bus <go or goes> <what>,
all day long.
```
So the function generating a single verse (`wheels.verse`) needs three inputs, `object`, whether the object is `plural` or not (which determines whether we use the verb "go" or "goes") and `what` the object does. 

The second function (`wheels`) then uses a loop to use `wheels.verse` to generate the lyrics one verse after the other and then puts the verses together and returns them. The second function takes a vector of `object`s, `plural`s and `what`s as arguments (which defaults set to generate the above lyrics).
```r
library(stringr)

#' Generate a single verse from the Wheels on the Bus
#' @param object object of the verse (defaults to "wheels")
#' @param plural whether the object is a plural (defaults to TRUE)
#' @param what what the object does without the word "go"
#'             (defaults to "round and round")
#' @return one verse about the \code{object} going code{what}
wheels.verse <- function(object="wheels", plural=TRUE, what="round and round") {
    go.goes <- ifelse(plural, "go", "goes")
    str_c("The ",object ," on the bus ", go.goes, " ", what, ",\n", what, ", ", what,".\n",
          "the ",object, " on the bus ", go.goes, " ", what, ",\nall day long.\n")
}

#' Generates all verses of the Wheels on the Bus
#' @param objects objects of the verse (defaults to the standard lyrics)
#' @param plurals whether the objects are a plural word
#'                (defaults to the standard lyrics))
#' @param what what the object does without the word "go"
#'             (defaults to the standard lyrics)
#' @return all verses of the lyrics of the song
wheels <- function(objects=c("wheels", "wipers", "horn", "people"),
                   plural=c(TRUE, TRUE, FALSE, TRUE),
                   what=c("round and round", "swish swish swish",
                          "beep beep beep", "up and down")) {    
    verses <- character(length(objects))
    for (i in seq_along(verses))
        verses[i] <- wheels.verse(objects[i], plural[i], what[i])
    # The function wheels.verse accepts vector input so we could have
    # just used
    # verses <- wheels.verse(objects, what)
    str_c(verses, collapse="\n")
}

cat(wheels())
```
#####[/answer]

####[/task]


### Unit testing
When programming it is important that we make sure that our programmes work as intended. So every time you have written a piece of code (especially a function), you should test it systematically. This way you can ensure that it is indeed working as intended. 

It pays off to confront possible issues as early as possible. It is much easier to test small blocks of code, rather than big blocks of code. Thus it is much better to use many small functions than a few big ones. This way, each of the functions can be tested individually, and once a bug is found, it can be identified fairly quickly.

There are in principle two ways how software can be checked:

- "White-box testing": One can inspect and review the source code of the programme. This is typically only useful if the code is checked by someone other than the author of the programme. However, this makes code review expensive and thus it is often only used for safety-critical or security-critical software. It is however also used for statistical programmes used in clinical trials. 
- "Black-box testing": Alternatively, one can apply the function to a number of test cases for which the correct output and behaviour of the function can be predicted. This form of testing is much simpler. However the test cases used might not cover every possible scenario, so some bugs might remain unnoticed.

<!--
BLACK-BOX TESTING EXAMPLE
-->

For more complex projects, unit testing can be automated and structured using the functions from the package [testthat](https://cran.r-project.org/web/packages/testthat/index.html) (see also the chapter on [Testing](http://r-pkgs.had.co.nz/tests.html) in [Hadley Wickham's book on R packages](http://r-pkgs.had.co.nz/)).

In some settings (e.g. statistical analysis of clinical trials) it is not uncommon to have two programmers implement the same tasks independently. When finished, the code produced by the two programmers is then run and the results are compared. This allows spotting mistakes, unless both programmers make the same mistake.


<!--[if PDF]>
\newpage
<![endif]-->
