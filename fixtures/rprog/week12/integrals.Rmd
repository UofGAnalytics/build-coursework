## Numerical integration in R

So far, we have looked at numerical methods for optimisation and for root finding. In this section we will look at numerical methods for approximating integrals.

The integral $\int_a^b f(x)\;dx$, which is the area under the function $f(\cdot)$ between $a$ and $b$, can be approximated by the total area of the trapezoids shown below:

![Approximation of an integral using trapezoids](integral.pdf)

As the number of trapezoids increases and the width of each trapezoid tends to 0, the two areas become identical. If we use $n$ trapezoids of equal width $\frac{b-a}{n}$, the total area of the trapezoids is
$$
\sum_{h=1}^n \frac{b-a}{n}\cdot \frac{f(x_{h-1})+f(x_h)}{2}= 
\frac{b-a}{2 n} f(x_0) + \frac{b-a}{n}\sum_{h=1}^{n-1} f(x_h) + \frac{b-a}{2 n} f(x_n),
$$
where $x_h=a+\frac{h}{n}(b-a)$.

This can be generalised to the following weighted approximation
$$
\int_a^b f(x)\;dx \approx \sum_{h=0}^n w_h \cdot f(x_h)
$$
The trapezoidal rule illustrated above corresponds to one specific choice of (equally spaced) support points $x_0,\ldots x_n$ and weights 
$$w_h=\left\{\begin{array}{ll} \frac{b-a}{2 n} & \textrm{ for $h=0$ or $h=n$} \\ \frac{b-a}{n}& \textrm{ otherwise.}\end{array}\right.
$$

It turns out that this choice is not optimal. [Gaussian quadrature](https://en.wikipedia.org/wiki/Gaussian_quadrature) obtains a more precise approximation by not equally spacing the support points. Gaussian quadrature even obtains the exact result for polynomials of degree up to $2n-1$.

The R function 
```{r eval=FALSE}
integrate(f=f, lower=a, upper=b, ...) 
```
performs an adaptive version of Gaussian quadrature to compute (an approximation to) the one-dimensional integral
$$
\int_a^b f(x)\;dx
$$
`f` is hereby an R function whose first argument is the variable we want to integrate over. The function `f` must accept vectorised input: If the first argument of `f` is a vector, it has to return a vector of the same length with the $i$-th element being $f(x_i)$. Additional arguments can be passed on to `f` using the `...` argument of `integrate`. The bounds `a` and `b` may be infinite. 

Just like solving equations or maximising functions numerically, numerical integration methods can fail in many ways, so don't trust the results too blindly. Especially, don't expect the methods to work well for functions with singularities, or any function which over the domain of integration cannot be approximated well by a polynomial.

###[example]
You have seen in *Probability and Stochastic Models* that the expected value of the exponential distribution with rate $\theta$ is $E(X)=\frac{1}{\theta}$, so if the rate $\theta=2$ then the expected value should be $0.5$. We will now check this using `integrate`.

```{r}
integrate(function(x) dexp(x, rate=2)*x, lower=0, upper=+Inf)
```
###[/example]
`integrate` only integrates numerically. Software like [Maple](https://www.maplesoft.com/products/Maple/), [Mathematica](https://www.wolfram.com/mathematica/), [Wolfram Alpha](https://www.wolframalpha.com/)  or [Maxima](http://maxima.sourceforge.net/) can also integrate symbolically, i.e. calculate the integral using the same integration rules as you would be using with pen and paper. 

`integrate` can only compute univariate integrals. The function `adaptIntegrate` from the package [cubature](https://cran.r-project.org/web/packages/cubature) can be used to compute integrals in higher dimension. High-dimension integrals are however typically easier to compute using Monte-Carlo methods. You will learn more about this in *Uncertainty Assessment and Bayesian Computation*.
