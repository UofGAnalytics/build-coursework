## Review exercises


###[task]
Use R to compute $\exp(1)$, $\left(1+\frac{1}{1000}\right)^{1000}$, $\left(\frac{1}{56}\right)^{\frac14}$.

####[answer]

<!--[if PDF]>
\mbox{ }
<![endif]-->

#####[video, videoid="uOlhoax1ljE", duration="1m52s"]Walk-through model answers

You can use the following R code.
```{r}
exp(1)
(1+1/1000)^1000                        # Very close to exp(1)
(1/56)^(1/4)
```
####[/answer]
###[/task]

###[task]Babylonian method
The *Babylonian method* provides a way of approximating $\sqrt{2}$. The sequence defined recursively by
$$
x_{n}=\frac{x_{n-1}}{2}+\frac{1}{x_{n-1}}
$$
tends to $\sqrt{2}$ as $n\longrightarrow \infty$ (provided $x_0>0$).  


(a) Define a new variable \texttt{x} taking the value 1.
(b) Update \texttt{x} to take the value
  $$
\frac{x}{2}+\frac{1}{x}.
$$
(c)  Repeat the update from part (b). You should see that x tends to $\sqrt{2}$.
You will learn later on in this course how to use loops to do this more efficiently. If you already know how to use loops, feel free to use them in this question.

####[answer]

\mbox{ }

#####[video, videoid="dfpxz4NSoz8", duration="1m58s"]Walk-through model answers

You can use the following (inelegant) R code.
```{r}
x <- 1
x <- x/2 + 1/x
x <- x/2 + 1/x
x <- x/2 + 1/x
x <- x/2 + 1/x
x
```
We'll cover loops later on  in the course. Loops allow us to write
```{r}
x <- 1
for (i in 1:20)                        # Repeat 20 times
    x <- x/2 + 1/x
```

\newpage

####[/answer]
###[/task]


###[task]
Explain what values the logical vectors \texttt{c}, \texttt{d} and \texttt{e} will take before running the code in R. 
```r
a <- c(TRUE, FALSE)
b <- c(FALSE, FALSE)
c <- (!a & !b)
d <- !(a & b)
e <- !(a | b)
```
####[answer]

\mbox{ }

#####[video, videoid="c_QOXJ-SdmU", duration="3m25s"]Walk-through model answers

```{r, echo=FALSE}
a <- c(TRUE, FALSE)
b <- c(FALSE, FALSE)
c <- (!a & !b)
d <- !(a & b)
e <- !(a | b)
```
The three logical vectors evaluate to ...
```{r}
c
d
e
``` 

####[/answer]
###[/task]

###[task]
Consider two logical variables `a` and `b` generated using the code below
```{r}
a <- sample(c(TRUE, FALSE), 1)
b <- sample(c(TRUE, FALSE), 1)
```
which randomly sets each of them to either `TRUE` or `FALSE`.
Use the operators `&`, `|`, `!` and/or `==` to define a new variable `c` in terms of `a` and `b`, which is `TRUE` if `a` and `b` are either both `TRUE` and `FALSE`. Otherwise `c` should be `FALSE`.
Can you think of more than one way of defining `c`?
  
####[answer]

\mbox{ }

#####[video, videoid="pLiYKl02XCc", duration="1m46s"]Walk-through model answers


```{r,echo=FALSE}
a <- sample(c(TRUE, FALSE), 1)
b <- sample(c(TRUE, FALSE), 1)
```
We can use
```{r}
c <- (a & b) | (!a & !b)
```
or
```{r}
c <- a==b
```

####[/answer]

###[/task]


###[task]
Create the following patterned sequences as efficiently as possible.
```
1 2 3 4 5 ... 10
1 2 3 1 2 3 1 2 3 1 2 3
1 1 2 2 3 3 
1 2 3 4 ... 18 19 20 19 18 ... 4 3 2 1 
1 4 9 16 25 36 49 64 81 100
1 2 4 8 16 32 64 128 256 512 1024
```
  
####[answer]

\mbox{ }

#####[video, videoid="MAsFM_wtkiE", duration="2m36s"]Walk-through model answers


You can use the following R code (there are many alternatives ...)
```{r}
1:10
rep(1:3, times=4)
rep(1:3, each=2)
c(1:20, 19:1)
(1:10)^2
2^(0:10)
```
 
####[/answer]

###[/task]


###[task]
Use R to calculate (or approximate) the following sums and products.
$$
\sum_{i=0}^9 2^i\qquad\mbox{and}\qquad \sum_{i=1}^{+\infty}\frac{1}{2^i}
$$

####[answer]

\mbox{ }

#####[video, videoid="Y8aj4K4MiXo", duration="2m13s"]Walk-through model answers

You can use the following R code (there are many alternatives \dots)
```{r}
sum(2^(0:9))                           # Happens to be 2^10-1 (why?)
sum(1/2^(1:1e5))
```
We cannot use `Inf` in the latter expression. It would require allocating an infinite amount of memory to store the sequence `1:Inf`, so we have to be pragmatic and use a large number instead.

####[/answer]

###[/task]


###[task]


(a) Create the following matrix and store it as `P`.
  $$\mathbf{P}=\left(\begin{array}{ccccc}1 & 0 & 0 & -1 & 0\\0 & 5 & 0 & 0 & 0\\3 & 0 & 1 &0 &0\\0 & 0 & 0 & 7 & 0\\0 & 0 & 0 & 0 & 9\end{array}\right)$$
(b) Print the first row and the second column of `P`.
(c) Print the submatrix that consists of the first three rows and first two columns of `P`.
(d) Compute the transpose and inverse of `P`.
(e) Replace the first row of `P` by $(1,2,3,4,5)$.
(f)  Replace all non-zero entries of the matrix `P` by $1$.

####[answer]


\mbox{ }

#####[video, videoid="SevO7zrfR0s", duration="4m03s"]Walk-through model answers


It is easiest to start with a diagonal matrix and then set the few off-diagonal entries which are not 0.
```{r}
P <- diag(c(1,5,1,7,9))
P[1,4] <- -1
P[3,1] <- 3

P[1,]
P[,2]

t(P)
solve(P)

P[1,] <- 1:5

P[P!=0] <- 1 
```
####[/answer]

###[/task]


###[task]Monte Carlo integration
Suppose we want to calculate the integral
$\int_0^1 f(x)\; dx$
for the function 
$$
f: \; [0,1] \rightarrow [0,1], \; x \mapsto f(x)=1-\exp(\sin(\pi x)^2)\cos(\pi x)^2.
$$

Integrating this function is non-trivial, so we will compute this integral using a simulation ("Monte Carlo integration") You will learn about more sophisticated Monte Carlo methods in the *Uncertainty Assessment and Bayesian Computation*.

Suppose we consider uniform "rain" falling on the unit square $[0,1]\times[0,1]$. The probability of a "rain drop" falling below $f(x)$ (purple area in the figure below) is just the area under the function, which is nothing other than the integral of interest, $\int_0^1 f(x)\;dx$. 

```{r, echo=FALSE, out.width=".75\\textwidth"}
t <- seq(-0.1,1.1,len=1e4)
f <- function(x)
    1-exp(sin(pi*x)^2)*cos(pi* x)^2
plot(t, f(t), type="n", xlim=c(0,1), ylim=c(0,1), xlab="x", ylab="f(x)")
s <- t>=0 & t<=1
rect(0,0,1,1,col="#9bd0fa", border=NA)
polygon(t[s], f(t[s]), border=NA, col="#fa9be1")
lines(t, f(t), lwd=2, col="#951272")
n <- 100
x <- runif(n)
y <- runif(n)
points(x, y, col="003865", bg="#951272", pch=ifelse(y<f(x), 21, 1))
```

We can thus estimate $\int_0^1 f(x)\;dx$ as follows.

- We first draw a large number (say $n=10,000$) points $(x_i,y_i)$ uniformly from the unit square $[0,1]\times[0,1]$.
- The integral $\int_0^1 f(x)\;dx$ is then estimated by the proportion of simulated points for which $y_i\leq f(x_i)$.

Implement this method to estimate the integral $\int_0^1f(x)\;dx$.
 
*Hint:* The function `runif(n)` generates $n$ random numbers, uniformly distributed between 0 and 1.

####[answer]


\mbox{ }

#####[video, videoid="Pfe1DNiwAv0", duration="4m52s"]Walk-through model answers

You can use the following R code.
```{r}
n <- 1e6                               # Set sample size
x <- runif(n)                          # Sample random x coordinates
y <- runif(n)                          # Sample random y coordinates
fx <-1-exp(sin(pi*x)^2)*cos(pi* x)^2   # Calculate f(x)
integral <- sum(y<=fx) / n             # Integral is proportion of points below f
integral
```
We can check our result against the result obtained from R's built-in integration function (we'll look at this function in more detail towards the end of the course)
```{r}
f <- function(x)                       # Define f as a function
  1-exp(sin(pi*x)^2)*cos(pi* x)^2
integrate(f, 0, 1)
```

If you want to know how I have created the figure, the code is below:
```r
t <- seq(-0.1,1.1,len=1e4)
plot(t, f(t), type="n", xlim=c(0,1), ylim=c(0,1), xlab="x", ylab="f(x)")
s <- t>=0 & t<=1
rect(0,0,1,1,col="#9bd0fa", border=NA)
polygon(t[s], f(t[s]), border=NA, col="#fa9be1")
lines(t, f(t), lwd=2, col="#951272")
n <- 100
x <- runif(n)
y <- runif(n)
points(x, y, col="003865", bg="#951272", pch=ifelse(y<f(x), 21, 1))
```
####[/answer]

###[/task]


\newpage

<!--[if PDF]>
\newpage
<![endif]-->
