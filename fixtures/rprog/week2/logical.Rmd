## Logical variables and comparisons

###[video, videoid="Xrm1cp-WSLM", duration="6m48s"] Logical variables and comparison operators

### Logical variables

A logical variable can only hold the two values `TRUE` and `FALSE`. Logical variables are sometime called Boolean variables, after George Boole (1815--1864), an English mathematician, logician and philosopher. R has the following three binary operators `!` (negation), `&` (logical AND) and `|` (logical OR).

| `expr1` |  `expr2`  | `!expr1` (NOT) | `expr1 & expr2` (AND) | `expr1 | expr2` (OR) |
|------|------|------|------|------|
|`TRUE`|`TRUE`|`FALSE`|`TRUE`|`TRUE`|
|`TRUE`|`FALSE`|`FALSE`|`FALSE`|`TRUE`|
|`FALSE`|`TRUE`|`TRUE`|`FALSE`|`TRUE`|
|`FALSE`|`FALSE`|`TRUE`|`FALSE`|`FALSE`|


####[example]
```{r}
a <- TRUE
b <- FALSE
c <- a & !b
c
```
In this example `c` is `TRUE`, because `!b` is `TRUE` and `TRUE & TRUE` is `TRUE`.
####[/example]

In R, `&` has higher precedence than `|`. So, in the absence of parentheses, `&` is evaluated before `|`. For example, `TRUE | FALSE & FALSE` is treated by R as `TRUE | (FALSE  & FALSE)`, which is `TRUE`. We have to use parentheses to calculate `(TRUE | FALSE)  & FALSE`, which is `FALSE`. 

####[task]
Consider three logical variables.
```{r}
a <- TRUE
b <- FALSE
c <- TRUE
```
Without using R determine the values of ...
```{r, results='hide'}
!a & b
a | !b
!(a | !b)
(a & b) | c
```
#####[answer]
If we use R to work out the answers we obtain
```{r, results='hide', echo=FALSE}
a <- TRUE
b <- FALSE
c <- TRUE
```
```{r}
!a & b
a | !b
!(a | !b)
(a & b) | c
```
#####[/answer]
####[/task]


####[supplement] TRUE and FALSE vs. T and F 
R also allows using the shorthands `T` instead of `TRUE` and `F` instead of `FALSE`. It is however *not* recommended to use these shorthands. Whereas `TRUE` and `FALSE` are reserved keywords, which cannot be overwritten, `T` and `F` are just global variables set to `TRUE` and `FALSE`, respectively. This means they can be masked by local variables. Nothing (in R) prevents you from setting
```{r}
T <- FALSE
F <- TRUE
```
and `T` and `F` have become the exact opposite of what they are meant to be! Of course, few users would do this deliberately, but it is not inconceivable that you happen to define a variable `T` or `F`, which can, depending on its values, have exactly the same effect.
####[/supplement]

####[supplement] && and || vs. & and |
R also has "lazy" operators `&&` and `||`. In contrast to `&` and `|` they will only evaluate the arguments until the result has become clear. On the other hand, `&` and `|` will always evaluate all arguments. `expr1&&expr2` will evaluate `expr2` only if `expr1` is `TRUE` (otherwise the result is guaranteed to be `FALSE` no matter what `expr2` is). Similarly, `expr1||expr2`  will evaluate `expr2` only if `expr1` is `FALSE` (otherwise the result is guaranteed to be `TRUE` no matter what `expr2` is). `&&` and `||` can be helpful in conditional `if` statements. You should *not* use `&&` and `||` for vectors of length greater than 1.

In contrast to many other programming languages `&` and `|` are not bitwise operators when applied to numbers, but simply coerce the number to a logical variable (ie. everything other than 0 will be treated as `TRUE`).
####[/supplement]


### Comparison operators
The comparison operators in R are `==` (testing for exact equality), \texttt{!=} ("not exactly equal") `<`, `<=`, `>`, and `>=`.

The comparison operators return a logical value (i.e. `TRUE` or `FALSE`), so you can use the operators `!`, `&` and `|` to combine them to more complex expressions.

####[example]
Consider a variable `x` set to the number 2.
```{r}
x <- 2
```
We can then test whether it is negative or less than or equal to 3.
```{r}
x < 0
x <= 3
```
If we want to test whether `x` is in the unit interval we can use
```{r}
x>0 & x<1
````
or, equivalently,
```{r}
!(x<=0 | x>=1)
```
####[/example]

Due to rounding and representation errors, you do not want to use `==` to compare non-integers. For example, despite $0.3 - 2 \times 0.1=0.1$, R yields
```{r}
0.3 - 2 * 0.1 == 0.1
```
because the expression on the left-hand side is not exactly 0.1. We see this by subtracting 0.1 from the left-hand side (which should then be exactly zero, but isn't)
```{r}
0.3-2*0.1 - 0.1
```
For non-integers we really only want to test whether they are "nearly equal", we can do so by comparing the absolute difference to a small number (say $10^{-8}$).
```{r}
abs(0.3-2*0.1 - 0.1) < 1e-8
```
or use the built-in function `all.equal`.
```{r}
isTRUE(all.equal(0.3-2*0.1, 0.1))
```

####[task]
Create a variable `x` storing the fraction $\frac{355}{113}$. Use R to test

- whether this fraction is less than $\pi$ (`pi` in R), 
- whether this fraction is  between 3 and 4, and
- whether this fraction is within $\pm 10^{-6}$ of $\pi$.

#####[answer]
We can use the following R code.
```{r}
x <- 355 / 113
x < pi
x>3 & x<4
abs(x-pi) < 1e-6
```
#####[/answer]

####[/task]




<!--[if PDF]>
\newpage
<![endif]-->
