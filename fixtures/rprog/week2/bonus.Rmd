## Bonus material (not assessed)

*This section covers additional material, which I hope you will find useful, but it is not part of the learning outcomes for this course.*

In this section we will look at manipulating character strings using the `stringr` package, which provides an easier interface for working with strings than the standard functions in R's `base` package. The package contains many more functions than what we can cover on this sheet. Practical data science often requires working with character strings and manipulating these.

###[weblink, target="https://github.com/rstudio/cheatsheets/raw/master/strings.pdf"]`stringr` Cheat Sheet
RStudio have put together a very handy and compact cheat sheet for `stringr`.
###[/weblink]

### Concatenating strings (revisited)
Earlier this week we looked at the function `str_c` (base R equivalent `paste` and `paste0`.
```{r}
library(stringr)
str_c("One", "part", sep=" ")
```
When providing at least one vector of character strings (of length exceeding 1), `str_c` returns a vector of strings, using the standard ``recycling rules''
```{r}
str_c(c("One", "another"),  "part", sep=" ")
```
The vector `str_c` would return a single string by supplying the additional argument `collapse`
```{r}
str_c(c("One", "another"), "part", sep=" ", collapse=" and ")
``` 
`str_c` will automatically coerce its arguments to character strings.

#
####[task]
Use `str_c` to create the string
```{r, echo=FALSE}
str_c(1:9, collapse=", ")
```

#####[answer]
We can use the following R code.
```{r}
library(stringr)
str_c(1:9, collapse=", ")
```
#####[/answer]

####[/task]

### Subsetting strings ("substrings")

You can extract substrings using the function `str_sub(s, from, to)` (base R equivalents: `substr`, `substring`).
```{r}
s <- "Ludger tends to be late for everything."
str_sub(s, 20, 23)
```
You can omit `from` (in which case you have to use `to=to` so that R knows what argument you provide)  or `to` if you want to start from the beginning of the string or want to extract everything up to the end of the string.
```{r}
str_sub(s, 20)
```

The function `str_length` (base R equivalent: `nchar`) returns the number of characters in a string.

####[task]
Define a string containing the text "Online MSc in Data Analytics" and extract the word "Data" from it using `str_sub`.

You have to count the letters or experiment with different values for `from` and `to`. Later on we will look at a more elegant way for matching parts of a string.

#####[answer]
You can use the following R code
```{r}
s <- "Online MSc in Data Analytics"
str_sub(s, 15, 18)
```
#####[/answer]
####[/task]


### Regular expressions
[Regular expressions](https://en.wikipedia.org/wiki/Regular_expression) are a very powerful framework for pattern matching and pattern extraction for strings and are available in most programming languages. The syntax for regular expressions is very rich, we will only look at its most simple elements.

Regular expressions are typically used to test whether a string contains a certain substring. This can be done using the function `str_detect` (base R equivalent: `grepl`).
```{r}
str_detect("Online MSc in Data Analytics", "Data")
```

`str_detect` returns `TRUE` as "Online MSc in Data Analytics" contains the word "Data".

Rather then looking for a specific word, regular expressions allow you to specify a pattern that needs to be matched.

#### Wildcards
The symbol `.` has a special meaning in regular expressions. `.` can match any single character. For example `h.t` matches for example "hat", "hit", "hot" and "hut", but not "ht" (no character) or "heat" (two characters).
```{r}
str_detect(c("hat", "hit", "hot", "hut", "ht", "heat"), "h.t")
```

#### Character sets
If we want to only match a subset of characters we can use character sets. These are delimited by square brackets. For example, `[aou]` matches any one character out of "a", "o" or "u", i.e. `h[aou]t` matches "hat", "hot" and "hut", but not "hit" (wrong character) or "ht" (no character) or "hoot" (two characters).
```{r}
str_detect(c("hat", "hot", "hut", "hit", "ht", "hoot"), "h[aou]t")
```


Inside character sets we can also use ranges like `[A-Z]`, `[A-Za-z]` or `[0-9]`. 

A `^` after the opening bracket (i.e. `[`)  negates the choice. For example `[^aou]` matches any character other than "a", "o" or "u". So `h[^aou]t` would match "hit", but not "hot" ("o" being excluded), "ht" (no character) or "hint" (two characters).
```{r}
str_detect(c("hit", "hot", "ht", "hint"), "h[^aou]t")
```

#### Quantifiers
A single wildcard or character set on its own will match exactly one character, unless we follow it by a quantifier.

Quantifier | Meaning
-----------|--------------------
`.` | exactly one character
`.?` | no or one character
`.+` | at least one character
`.*` | no, one or more characters
`.{n}` |  exactly $n$ characters
`.{m,n}` | from `m` to  `n` characters

Characters or character sets could be used instead of `.`.

For example `h.+t` would match "hot", "hint", but not "ht" (no character). "ht" would however be matched by `h.?t` or `h.*t`.

Course codes in our subject start with "STATS", followed by a 4-digit code, which starts with the digit 1 to 5, i.e. the numeric part is made up of the first digit (1 to 5), and then three more digits, i.e. the corresponding regular expression
```
STATS[1-5][0-9]{3}
```

#### Alternatives
`(a|b)` matches either `a` or `b`. For example, `H(ä|a|ae)ndel` matches all plausible ways of spelling the surname of the baroque composer Georg Friedrich Händel (sometimes also spelled Heandel or Handel). We could not have used character sets in this example, as `H[äae]{1,2}ndel` would have also matched "Haandel" or "Heandle".

#### Beginning and end
A regular expression will also match a substring, so for example `d.g` would match a substring of "A pug is a dog."
```{r}
str_detect("A pug is a dog", "d.g")
```
If we only want to match strings which start with the pattern `d.g` we have to put a `^` at the beginning. If we want to match a pattern which has to be at the end of a string we have to put a `$` at the end. For example
```{r}
str_detect("A pug is a dog", "^d.g")
```
```{r}
str_detect("A pug is a dog", "d.g$")
```` 

For the following tasks you need to load some data. After running
```{r}
load(url("http://www.stats.gla.ac.uk/~levers/rp/addresses.RData"))
```
you should have a vector called `addresses` in your workspace, which contains the addresses of property transactions in Greater Glasgow between July 1st and December 31st 2014.


#####[task]

(a) Use `str_detect` to find the addresses referring to properties with a four digit house number (address field starting with four digits).      
(b) Use `str_detect` to find the addresses referring to properties in the following roads : "Church Street", "Church Lane" or "Church Place" (the data set might contain further streets like "Church Road" or "Church Crescent", which we are not interested in).

######[answer]
We can use the following R code for parts (a) and (b).
```{r}
load(url("http://www.stats.gla.ac.uk/~levers/rp/addresses.RData"))
# Part (a)
select <- str_detect(addresses, "[0-9]{4}")
head(addresses[select])
# Part (b)
select <- str_detect(addresses, "Church (Street|Lane|Place)")
addresses[select]
```
######[/answer]

#####[/task]

#### Extracting matched parts

The function `str_match` extracts the first substring that matches a pattern.
```{r}
str_match("You are taking the courses STATS5077 or STATS 5094 and STATS5058.", 
          "STATS[1-5][0-9]{3}")
```
If you want to match not just the first, but all occurrences use `str_match_all`.
```{r}
str_match_all("You are taking the courses STATS5077 or STATS 5094 and STATS5058.", 
              "STATS[1-5][0-9]{3}")
``` 

#####[task]
A British postcode is made up as follows:

- one or two capital letters, followed by
- one or two digits, followed by
- one optional capital letter, followed by 
- a single space, followed by
- a single digit, followed by
- two capital letters.

Create a new vector `postcode` which only contains the postcode.

The official definition of a UK postcode is slightly more protracted, yielding the regular expression
```
^([Gg][Ii][Rr]0[Aa]{2})|((([A-Za-z][0-9]{1,2})|(([A-Za-z][A-Ha-hJ-Yj-y][0-9]{1,2})|
(([A-Za-z][09][A-Za-z])|([A-Za-z][A-Ha-hJ-Yj-y][0-9]?[A-Za-z]))))[0-9][A-Za-z]{2})$
```

######[answer]
We can use the following R code.
```{r}
postcode <- str_match(addresses, "[A-Z]{1,2}[0-9]{1,2}[A-Z]? [0-9][A-Z]{2}")
head(postcode)
```


######[/answer]
#####[/task]

### String interpolation with glue

The package [glue](https://cran.r-project.org/web/packages/glue/index.html) takes inspiration from [f-strings in Python](https://www.python.org/dev/peps/pep-0498/) and make assembling strings a lot more convenient.

Suppose we have variable a variable
```{r}
name <- "Paul"
favourite.pet <- "dog"
```
and want to create the sentence
```{r}
str_c(name, "'s favourite pet is a ", favourite.pet, ".")
```
This requires a lot of quotes and commas, which can easily get messy. `glue` allows a more compact syntax: it evaluates expressions in curly brackets so we can use
```{r}
library(glue)
glue("{name}'s favourite pet is a {favourite.pet}.")
```

`glue` can also evaluate more complex expressions:
```{r}
p <- 0.3
glue("A proportion of {p} corresponds to {100*p}%.")
```
