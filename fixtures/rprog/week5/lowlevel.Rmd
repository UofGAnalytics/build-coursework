## Low-level plotting functions

```{r, echo=FALSE, message=FALSE}
palette(c('#FFFFFF', '#951272',  '#00843D', '#003865', '#BE4D00', '#0075B0', '#B30C00', '#FFDC36', '#00B5D1', '#7D2239',  '#AA8066', '#5B4D94', '#FFB948'))
library(magrittr)
library(dplyr)
load(url("http://www.stats.gla.ac.uk/~levers/rp/w5.RData"))
```


### Adding to plots using points and lines
The function `lines` and `points` can be used to add lines or points to
an existing plot. `lines` behaves like `plot` using `type="l"`, and
`points` behaves like `plot` using `type="p"`, except that the
points/lines are added to the active plot, rather than a new plot. `points` and `lines` can be used the same way as `plot` (except for the arguments `title`, `sub`, `xlim`, `ylim`, `log`, `type`, which cannot be used).

####[example, label="plotusukaus"]
Suppose we want to highlight the observations belonging to the UK, the US and Australia in the plot of health expenditure and life expectancy. 

We start with redrawing the plot
```r
plot(LifeExpectancy~HealthExpenditure, data=health, col=1+unclass(Region))
```
Then we can extract the data belonging to these three countries ...
```{r}
health2 <- health %>%
    filter(Country %in% c("Australia", "United Kingdom", "United States"))
```
... and we can then draw the points for these three countries with a filled circle (`pch=16`) and twice the size (`cex=2`):
```r
health2 %$%
    points(HealthExpenditure, LifeExpectancy, col=1+unclass(Region), pch=16, cex=2)
```
```{r, echo=FALSE, dev.args=list(pointsize=10)}
plot(LifeExpectancy~HealthExpenditure, data=health, col=1+unclass(Region))
health2 %$%
    points(HealthExpenditure, LifeExpectancy, col=1+unclass(Region), cex=2, pch=16)
```
####[/example]

####[task,label=pointslinestask]
Consider two vectors `x` and `y` created using
```{r}
n <- 1e3
x <- runif(n, 0, 2*pi)                   # x is random uniform from (0,2*pi)
x <- sort(x)                             # Sort entries in x to avoid a mess
y <- sin(x)                              # Set y to the sine of x
y.noisy <- y + .25 * rnorm(n)            # Create noisy version of y
```
Consider the following two blocks of code:
```r
plot(x, y.noisy, ylab="y")
lines(x, y, col=2)
```
and
```r
plot(x, y, type="l", col=2)
points(x, y.noisy)
```
The two plots generated are shown below (in arbitrary order).
```{r, dev.args=list(pointsize=10), fig.width=10, fig.height=6, out.width="\\textwidth"}
par(mfrow=1:2)
plot(x, y, type="l")
points(x, y.noisy)
plot(x, y.noisy, ylab="y")
lines(x, y)
```

What is the difference between the two commands? Why do the plots looks different? Which plot comes from which command?

#####[answer]
The former set of commands first draws the noisy data and then adds the sine curve. The latter set of commands first draws the sine curve and then the noisy data. The noisy data have a greater range than the noise-free data. As `plot` determines the range of the y axis and this cannot be changed by `points` or `lines`,drawing the noisy points first (as done by the former command) gives a larger range of the y axis that can show all the data. Drawing the noise-free line first leads to a smaller range of the y axis, which is then too small to show all the noisy points. 

Thus the left-hand plot comes from the latter command (noise-free line first, then noisy points) and the right-hand plot comes from the former command (noisy points first, then noise-free line).

Another difference is that the former command plots the line above the points, whereas the latter plots the points above the line.
#####[/answer]
####[/task]

The function `abline` can be used to add a straight line to an existing plot:

- `abline(h=ypos, ...)` draws a horizontal line at `ypos`.
- `abline(v=xpos, ...)` draws a vertical line at `xpos`.
- `abline(a=intercept, b=slope, ...)`  draws a line with `intercept` as its intercept and `slope` as its slope.

`col`, `lwd` and `lty` can be used as additional arguments.

### Adding text

The function `text(x, y, text, ...)`  plots the text `text` (one character string or a vector of strings) at the coordinate(s) (`x`, `y`). The optional arguments include `col,` `cex`, and `adj=c(horiz, vert)`, which sets the horizontal adjustment to `horiz` (`0`: left justified, `0.5` centred, `1`: right justified) and the vertical adjustment to `vert` (`0`: bottom, `0.5` centre, `1`: top). The default is all centred `c(0.5, 0.5)`.

####[example]
Suppose we now want to label the observations belonging to the US, UK and Australia
 in the plot from ref://plotusukaus.

```r
health2 %$%
    text(HealthExpenditure, LifeExpectancy, Country, adj=c(1,1))
```
```{r, echo=FALSE, dev.args=list(pointsize=10)}
plot(LifeExpectancy~HealthExpenditure, data=health, col=1+unclass(Region))
health2 %$%
    points(HealthExpenditure, LifeExpectancy, col=1+unclass(Region), cex=2, pch=16)
health2 %$%
    text(HealthExpenditure, LifeExpectancy, Country, adj=c(1,1))
```

`adj=c(1,1)` gets the text to be "attached" to the coordinate systems at the top-right of each text label.
####[/example]

### Drawing rectangles and polygons

The functions `rect` and `polygon` can be used to draw filled rectangles
and polygons.

`rect(xleft, ybottom, xright, ytop, ...)` draws a rectangle with bottom left corner (`xleft`, `ybottom`) and top right corner (`xright`, `ytop`).

`polygon(x, y, ...)` draws a polygon the with vertices in (`x`, `y`). 

The following optional arguments can be used:

- `border`:   the colour of the outline. Use `border=NA` to draw no outline.
- `lwd` / `lty`:  the line width/line type of the outline.
- `col`:   the colour used for filling the polygon. Use `col=NA` for a transparent rectangle/polygon (i.e. with no fill).
- `density`: the density of shading lines (defaults to `NULL`, i.e no shading lines, but a solid fill is used).

####[example] 
The following R code draws a red circle of radius 1 having a blue
outline. Note the use of `plot` with argument `type=n` to set up the
plot (coordinate axes, etc.).

```{r, dev.args=list(pointsize=10)}
t <- seq(0, 2*pi, length.out=100)
circle <- cbind(sin(t), cos(t))
plot(circle, type="n", xlab="x", ylab="y")
polygon(circle, col="red", border="blue", lwd=2)
```

The circle looks more like an oval. In order to obtain a plot with perfectly equal scales (so that the circle looks like a circle) one can use the function `eqscplot` from the package `MASS` instead of `plot`.
####[/example]

<!--[if PDF]>
\newpage
<![endif]-->
