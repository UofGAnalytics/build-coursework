## Loops

### For loops

####[video, videoid="BivoKnOakVQ", duration="8m38s"]For loops

In the Week 2 material, we have looked at the so-called ``Babylonian Method'' for finding $\sqrt{2}$: the sequence defined by
$$
x_{n}=\frac{x_{n-1}}{2}+\frac{1}{x_{n-1}}
$$
tends to $\sqrt{2}$ as $n\longrightarrow \infty$ (provided $x_0>0$).

In order to approximate $\sqrt{2}$ using R we first set \texttt{x} to an initial value, say 1,
```{r}
x <- 1
```
and then had to repeatedly (say 10 times) update `x` using the recursive formula from above.
```{r}
x <- x/2 + 1/x
x <- x/2 + 1/x
x <- x/2 + 1/x
x <- x/2 + 1/x
x <- x/2 + 1/x
x <- x/2 + 1/x
x <- x/2 + 1/x
x <- x/2 + 1/x
x <- x/2 + 1/x
x <- x/2 + 1/x
```

Loops are a way of doing these "repetitive" steps in a more elegant (and flexible) way:
```[r}
x <- 1
for (i in 1:10) 
    x <- x/2 + 1/x
```

The general syntax of `for` loops is

```r
for (variable in sequence) {
    statement1
    ...
    statementn
}
```

The `for` loop executes the statements in the body of the loop (`statement1` to `statementn`) once for every element of `sequence`: the first time `variable` is set to the first element of `sequence` and the statements in the body are run using that value of `variable`, the second time `variable` is set to the second element of `sequence` and the statements in the body are run using `variable` set to that value, and so on.

If we wish to only iterate one statement we can omit the curly brackets.

####[example]
A simple example illustrating a `for` loop is 
```{r}
for (i in 1:3)
    print(i)
```
####[/example]

####[example]
The sequence we iterate over does not need to consist of numbers (though this is very often the case). We can use
```{r}
for (day in c("M", "Tu", "W", "Th", "F")) 
    print(day)
```

####[/example]

####[example]
We can use a `for` loop with an `if` statement to set all negative values of a vector `x` to 0.
```{r}
x <- rnorm(10)
for (i in seq_along(x))
    if (x[i]<0)
        x[i] <- 0
x
```
In this loop we want to iterate over the length of the vector `x`. We could have  used `1:length(x)`. However, this will not work if the length of `x` is 0. `1:length(x)` would then return the sequence $(1,0)$, rather than a sequence of length 0 as would be required. The function `seq_along(x)` does exactly the same as `1:length(x)`, except that it handles the case of a vector of length zero correctly.
####[/example]

####[example]AR(1) process
In this example we will use a `for` loop to generate a random sample of size 1000 from the model for an auto-correlated time series:
$$
\begin{array}{rcl}
X_1 &\sim& \textsf{N}(0,1)\\
X_{i} | X_{i-1}=x_{i-1} &\sim&\textsf{N}(0.8x_{i-1},0.6^2)
\end{array}
$$
One can show that the second line is equivalent to setting
$X_i = 0.8\cdot X_{i-1} + 0.6 \cdot \epsilon_i$, where $\epsilon_i\sim \textsf{N}(0,1)$

We start with creating an empty vector of the required size and setting its first entry to a random number drawn from the $\textsf{N}(0,1)$ distribution:
```{r}
n <- 1000
x <- numeric(n)
x[1] <- rnorm(1)
```
We simulate all the remaining entries using a \texttt{for} loop:
```{r}
for (i in 2:n) {                            # We start the loop at i=2!
    epsilon <- rnorm(1)
    x[i] <- 0.8*x[i-1] + 0.6 * epsilon
}
```
Finally, we can plot the results
```{r,  dev.args=list(pointsize=10), out.width=".7\\textwidth"}
plot(x, type="l")
```
####[/example]

####[task, label=looptask1]
Create a vector x containing some missing values using
```{r}
x <- rnorm(100)                      # Generate white noise
x[sample(100,10)] <- NA              # Sneak in 10 missing values
```
Use a loop to create a vector `y` which contains the entries of `x`, however with missing values replaced by 0. (Remember, you can use the function `is.na` to test whether a value is missing).

Can you do the same without a loop?

#####[answer]
You can use the following loop
```{r}
y <- numeric(length(x))
for (i in seq_along(x)) 
    if (!is.na(x[i])) {
        y[i] <- x[i]
    } else {
        y[i] <- 0
    }
```
In this example it is a lot easier to use subsetting.
```{r}
y <- x
y[is.na(y)] <- 0
```
#####[/answer]
####[/task]

####[task]
In the setting of the previous task, suppose that rather than setting the missing values to 0 we want to omit them from `y`. We can do so by setting
```{r}
y <- x[!is.na(x)]                    # Only copy non-missing entries
```
Can you modify your loop from ref://looptask1 to achieve the same?

#####[answer]
We create an empty vector `y` and only append the non-missing entries from `x`.
```{r}
y <- c()
for (i in seq_along(x)) 
    if (!is.na(x[i])) 
        y <- c(y, x[i])
```
The loop is a lot slower than the subsetting approach and also less clear to read (for a human).
#####[/answer]
####[/task]

### Nested loops
Loops can be nested within each other. Note that you have to use different names for the loop variables in nested loops. In the examples below the outer loop uses `i`, whereas the inner loop uses `j`.

####[example]
The following simple example illustrates how a nested loop works.
```{r}
for (i in 1:2)
    for (j in 1:3)
        print(c(i,j))
```
The nested loop loops over all combinations of $i\in\{1,2\}$ and $j\in\{1,2,3\}$. The index `j` changes fast, whereas the index `i` changes slowly. 
####[/example]

####[example]
When we looked at the standard plotting functions in R we created an image plot of the density of the bivariate normal distribution.

For the plotting function `persp` (or `filled.contour` or `image`) we need to store the values we want to plot in a matrix $\mathbf{Z}=(Z_{ij})$ with
$$
Z_{ij}=\phi(x_i)\cdot\phi(y_j)
$$ 

At the time, we used `expand.grid` to create all combinations of $x_i$ and $y_i$ in long format and then used `tidyr` to convert this into "wide" matrix format.

We could have also used a nested loop (which would however be slower). We start by creating the sequences `x` and `y` and then create an empty matrix to hold the $Z_{ij}$'s.
```{r}
x <- seq(from=-3, to=3, length.out=50)      # Create sequence of grid for the x axis
y <- seq(from=-3, to=3, length.out=50)      # Create sequence of grid for the y axis
z <- matrix(nrow=length(x), ncol=length(y)) # Create matrix to store function values
```
In order to set every value of the matrix we need to go through all rows and all columns. Thus we need two loops nested within each other:
```{r}
for (i in seq_along(x))                     # For all rows ...
    for (j in seq_along(y))                 # For all columns ...
        z[i,j] <- dnorm(x[i])*dnorm(y[j])   # Compute f(x,y)
```
Now we can create the plot:
```{r}
persp(x, y, z, theta=30, phi=30, col="yellow", shade=0.5) 
```
####[/example]

### break and next
A `for`-loop repeats the statements in it a fixed number of times. The `break` statement gives additional flexibility and allows for aborting the loop immediately and before the sequence of indices has been finished. It is typically used inside an `if` statement.

####[example, label="loop_baby2"]
In the motivating example at the start of this section we computed $\sqrt{2}$ using the Babylonian method, which is based on the iteration $x_{n}=\frac{x_{n-1}}{2}+\frac{1}{x_{n-1}}$. We implemented it using a `for` loop.
```{r}
x <- 1
for (i in 1:10) 
    x <- x/2 + 1/x
```
After the 10 iterations we obtained $x_{10}=1.4142135623730949$, which is quite close to $\sqrt{2}=1.4142135623730951$. Often, we are only interested in the first 8 digits, so we could have stopped the loop earlier, as soon as `x` changes by less than say $10^{-8}$. This can be done using `break`.

In order to be able to quantify by how much `x` has changed we need to store the previous value of `x` in a variable `x.old`:
```{r}
x <- 1
for (i in 1:100) {
    x.old <- x                             # Store the old value of x
    x <- x/2 + 1/x                         # Update x
    if (abs(x-x.old)<1e-8)                 # Check for convergence
        break
}
```
The `break` statement will abort the loop as soon as the change in `x` is less than $10^{-8}$. To find out how many iterations were necessary, we can simply print `i` after running the loop:
```{r}
i
```
Thus we needed only 5 iterations to obtain $\sqrt{2}$ to a precision of $\pm 10^{-8}$.
####[/example]

####[task]
In ref://loop_baby2 we have used a variable `x` to store the current value of $x$ in the recursive sequence. We had to introduce `x.old` to store the old value of `x`, so that we can compare to the current value in order to check for convergence.

Instead we could have used a vector `x` of length 100 and stored the value at the `i`-th iteration $x_i$ in the `i`-th entry of `x`. After the end of the loop the required value is then in `x[i]`. Rewrite the loop in that way.
#####[answer]
We can store the entire sequence (rather than just the store the current value) using the following R code.
```{r}
n <- 100
x <- numeric(n)
x[1] <-  1
for (i in 2:100) {
    x[i] <- x[i-1]/2 + 1/x[i-1]           # Update x
    if (abs(x[i]-x[i-1])<1e-8)            # Check for convergence
        break
}
x[i]
```
#####[/answer]
####[/task]

`next` halts the processing of the current iteration and goes back to the start of the body of the loop (using the next value of `sequence` in a `for` loop). `next` is the R equivalent of `continue` in C or Java.

####[example] 
The loop
```{r}
for (x in 1:10) {
    if (x%%2==0)
        next
    print(x)
}
```
prints all the odd numbers: if `x` is an even number `x%%2` is `0`, `next` is called, and thus the remainder of the statements in the body are skipped (before `x` is printed) and R continues with the next iteration.
####[/example]

In nested loops, `break` and `next` only affects the inner-most loops. R does not support `break`ing outer loops.


### while loops
There are occasions when we need to repeatedly perform some operations,
but we do not know in advance for how many times. As we have just seen, we can use `break` to stop the loop early. Another option is to use `while` loops (and `repeat` loops, which is the same as `while` loop without a condition).

The syntax of a `while` loop is

```r
while (condition) {
    statement1
    ...
    statementn
}
```

The `while` loop checks `condition` each time before executing the first statement in the body of the loop. It executes the loop only if the `condition` evaluates to `TRUE`. As soon as the `condition` evaluates to `FALSE` for the first time, the loop is aborted. 


####[example]
We consider again the Babylonian method for finding $\sqrt{2}$. Just like in ref://loop_baby2, we want to stop iterating as soon as the change in `x` is small enough.
```{r}
x <- 1
x.old <- 0
while(abs(x-x.old)>1e-8) {
    x.old <- x                             # Store the old value of x
    x <- x/2 + 1/x                         # Update x
}
x
```
####[/example]

####[example]A for loop using while 
We have seen that we can print the numbers 1 to 3 using a for loop:
```{r}
for (i in 1:3)
    print(i)
```
We can do the same using a `while` loop, but we have to "manage" `i`  ourselves.
```{r}
i <- 1
while (i<=3) {
    print(i)
    i <- i+1
}
```
####[/example]


####[weblink, target="https://blockly-games.appspot.com/"]Blockly games
Google has developed [Blockly](https://developers.google.com/blockly/) as a framework for creating interactive educational programming games. The idea behind Blockly games is that they visually illustrate control flow. Especially if you are new to programming, taking a look at some of these games might help develop your understanding of control structures and how they are best employed to solve a problem. 
The Blockly games generate JavaScript code, but being a "curly-bracket language" the control structures in JavaScript are very similar to the ones used by R (just ignore the semicolons at the end of each line). 
####[/weblink]


###[weblink, target="", icon="book"]Background reading: Sections 4.1.1 and 4.1.3  of A First Course in Statistical Programming with R
Sections 4.1.1 and 4.1.3 cover loops using `for` and `while`.
###[/weblink]

<!--[if PDF]>
\newpage
<![endif]-->
