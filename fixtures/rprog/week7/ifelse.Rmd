## The function ifelse

###[video, videoid="aeDz66Jopeg", duration="6m33s"]The function ifelse

We have seen that the condition of an `if` statement has to be of length 1. If we want to use a condition that is of length greater then 1, we need to use a loop to go through the vector one-by-one. The function `ifelse` provides a more compact way of doing so. In some way, `ifelse` is the vectorised sibling of `if` statements.

The function 
```r
result <- ifelse(condition, yes, no)
```
sets the $i$-th element of the result to the $i$-th element of `yes` if the $i$-th element of `condition` is `TRUE`, otherwise it will be set to the $i$-th element of `no`.

The length of `result` will be the same as the length of `condition`. If `yes` and `no` are shorter than `condition`, `ifelse` will use the standard recycling rules.


###[example]
We return to the example in which we set the negative entries of a vector `x` to 0.

If we want to use an `if` statement, we have to use a loop to go through the vector `x` one-by-one.
```{r, echo=FALSE}
x <- rnorm(10)
```
```{r}
for (i in seq_along(x))
    if (x[i]<0)
        x[i] <- 0
```
Using `ifelse` simplifies this a lot:
```{r}
x <- ifelse(x<0, 0, x)
```
###[/example]
Note that the assignment (`<-`) is always _outside_ the call to `ifelse`, whereas that assignment is typically _inside_ the `if` statement.

###[example]
Suppose we have two vector `x` and `y`
```{r}
n <- 5
x <- sample(n)
y <- sample(n)
```
each containing the integers 1 to 5 in a random order.

Suppose you want to set the $i$-th entry of a new vector `z` to $z_i=\max\{x_i,y_i\}$. You can do this by placing an `if` statement inside a `for` loop.

```{r}
z <- numeric(n)                  # Create vector to hold result
for (i in 1:n) {
  if (x[i]>y[i]) {               # If x[i] is larger ...
    z[i] <- x[i]                 # ... set z[i] to  x[i]
  } else {                       # Otherwise (i.e. if x[i] is not larger) ...
    z[i] <- y[i]                 # ... set z[i] to  y[i]
  }
}
```

It is a lot easier to use `ifelse`.
```{r}
z <- ifelse(x>y, x, y)
```

Note that we could have also used subsetting.
```{r}
z <- x                          # Start with a copy of x
select <- y>x                   # Find out for which entries y is larger than x
z[select] <- y[select]          # Set these to y
```
###[/example]

###[task]
Without running the code in R, determine what `ifelse` returns in the code snippet below.
```r
x <- c(1,2,9)
y <- c(2,6,4)
z <- c(3,5,7)
ifelse(x<4, y, z)
```
####[answer]
The call to `ifelse` returns the vector $(2,6,7)$. The condition evaluates to (`TRUE`,`TRUE`,`FALSE`), so the result is set to $(y_1,y_2,z_3)=(2,6,7)$.
####[/answer]
###[/task]

###[task]
What does the following loop do?
```r
x <- rnorm(10)                        # Generate some white noise
out <- numeric(length(x))
for (i in seq_along(x)) {
    if (x[i]>0) {
        out[i] <- x[i]
    } else {
        out[i] <- -x[i]
    }
}
```
Rewrite the code so that it uses the function `ifelse`.
####[answer]
The loop stores the modulus ("absolute value") of `x` in `out`. This can be recoded using `ifelse` as
```r
out <- ifelse(x>0, x, -x)
```
We could, of course, also have simply set
```r
out <- abs(x)
```
####[/answer]
###[/task]

<!--[if PDF]>
\newpage
<![endif]-->
